---
title: 'Chapter 18: Expressions'
author: "Paulo Magalang"
date: "2023-07-05"
output: html_document
---

```{r}
library(lobstr)
library(rlang)
```

# 18.1 Introduction

* way to separate expressions vs execution of expression? -> use `rlang::expr()`

```{r}
z <- rlang::expr(y <- x * 10)
z
```

```{r}
x <- 4
eval(z) # evaluate expressions with `base::eval()`
y
```

# 18.2 Abstract syntax trees (ASTs)

## 18.2.1 Drawing

* can draw ASTs with `lobstr::ast()`

```{r}
lobstr::ast(f(x, "y", 1))
```

* leaves of tree are symbols (in purple and rounded corners) or constants (black 
borders and square corners)

* branches of tree are objects (ie: function calls) and represented as orange rectangles

```{r}
lobstr::ast(f(g(1, 2), h(3, 4, i())))
```

## 18.2.2 Non-code components

* only one place where whitespace affects ASTs

```{r}
lobstr::ast(y <- x)
```

```{r}
lobstr::ast(y < -x)
```

## 18.2.3 Infix calls

```{r, eval = FALSE}
# recall both lines of code are equivalent
y <- x * 10
`<-`(y, `*`(x, 10))
```


```{r}
lobstr::ast(y <- x * 10)
```

## 18.2.4 Exercises

1. Reconstruct the code represented by the trees below:

```{r}
lobstr::ast(f(g(h())))
```

```{r}
lobstr::ast(1 + 2 + 3)

# how are parentheses included in ASTs?
#lobstr::ast((1 + 2) + 3)
```

```{r}
lobstr::ast((x + y) * z)
```

2. Draw the following trees by hand and then check your answers with `lobstr::ast()`.

```{r, eval = FALSE}
f(g(h(i(1, 2, 3))))
f(1, g(2, h(3, i())))
f(g(1, 2), h(3, i(4, 5)))
```


3. What's happening with the ASTs below? (Hint: carefully read `?"^"`.)

```{r}
lobstr::ast(`x` + `y`)
# in prefix form
```

```{r}
lobstr::ast(x ** y)
# `**` and `^` are equivalent
```

```{r}
lobstr::ast(1 -> x)
# x <- 1 and 1 -> x are equivalent
```

4. What is special about the AST below?

```{r}
lobstr::ast(function(x = 1, y = 2) {})
# x and y are arguments for function
# {} contains the code for the function (is it hidden in the AST if not empty?)

lobstr::ast(function(x = 1, y = 2) {x + y})

# not sure what `<inline srcref>` leaf refers to. source ref?
```

5. What does the call tree of an `if` statement with multiple `else if` conditions 
look like? Why?

```{r}
lobstr::ast(
  if (x == 0) {}
  else if (x < 1) {}
  else if (x >= 1) {}
)
# else if is equivalent to nested if statements
```


# 18.3 Expressions

## 18.3.1 Constants

* constants are either `NULL` or a length-1 atomic vector

```{r}
identical(expr(TRUE), TRUE)
identical(expr(1), 1)
identical(expr(2L), 2L)
identical(expr("x"), "x")
```

## 18.3.2 Symbols

* symbols represent the name of an object

* can create symbols by capturing code that references an object with `expr()` or 
turning a string into a symbol with `rlang::sym()`

```{r}
expr(x)
sym("x")
```

* can turn a symbol back into a string with `as.character()` or `rlang::as_string()`

```{r}
as_string(expr(x))
```

```{r}
str(expr(x))
is.symbol(expr(x))
```

## 18.3.3 Calls

* call objects represent a captured function call, are special lists

```{r}
lobstr::ast(read.table("important.csv", row.names = FALSE))
x <- expr(read.table("important.csv", row.names = FALSE))

typeof(x)
is.call(x)
```

## 18.3.3.1 Subsetting

* calls behave like lists

```{r}
x[[1]]
is.symbol(x[[1]])
```

```{r}
as.list(x[-1])

x[[2]]
x$row.names

length(x) - 1 # determine number of arguments
```

```{r}
# standardize all arguments to use the full name, useful for extracting specific arguments from a call
rlang::call_standardise(x)
```

## 18.3.3.2 Function position

* function position is the first element of the call object, contains the function that will 
be called

```{r}
lobstr::ast(foo())
lobstr::ast("foo"())
```

```{r}
lobstr::ast(pkg::foo(1))
lobstr::ast(obj$foo(1))
lobstr::ast(foo(1)(2))
```

## 18.3.3.3 Constructing

* can construct a call object using `rlang::call2()`

```{r}
call2("mean", x = expr(x), na.rm = TRUE)
call2(expr(base::mean), x = expr(x), na.rm = TRUE)

call2("<-", expr(x), 10)
```

## 18.3.5 Exercises

1. Which two of the six types of atomic vector can't appear in an expression? Why?
Similarly, why can't you create an expression that contains an atomic vector of length
greater than one?

Complex and raw atomic vectors cannot appear in an expression.

You cannot create an expression that contains an atomic vector of length greater
than one because it is impossible to create an atomic vector of length greater than
one without a function call (ie: `c()`, `:`).


2. What happens when you subset a call object to remove the first element? Why?

```{r}
expr(read.csv("foo.csv", header = TRUE))[-1]
```

The first element of the call object is the function position. Because we subset the call
object to remove the first element, "foo.csv" is treated as the function to be executed.

3. Describe the differences between the following call objects.

```{r}
x <- 1:10

call2(median, x, na.rm = TRUE)
call2(expr(median), x, na.rm = TRUE)
call2(median, expr(x), na.rm = TRUE)
call2(expr(median), expr(x), na.rm = TRUE)

# depends on what is being evaluated
# median: median function is evaluated which is why we see the extra
#         lines
# expr(median): median function is not evaluated
# x: argument becomes 1:10; expr(x): argument is x
```

4. `rlang::call_standardize()` doesn't work so well for the following calls. Why?
What makes `mean()` special?

```{r}
call_standardise(quote(mean(1:10, na.rm = TRUE)))
call_standardise(quote(mean(n = T, 1:10)))
call_standardise(quote(mean(x = 1:10, , TRUE)))
```

```{r}
mean
```

`mean` has `...` as an argument so arguments are not lazily evaluated and can allow
more arguments.

5. Why does this code not make sense?

```{r}
x <- expr(foo(x = 1))
names(x)
names(x) <- c("x", "y")

x
as.list(x)
```

`x` is now in the function position but the name of the function does not change.
`y` becomes the argument name.

5. Construct the expression `if(x > 1) "a" else "b"` using multiple calls to
`call2()`. How does the code structure reflect the structure of AST?

```{r}
lobstr::ast(expr(if(x > 1) "a" else "b"))
```

```{r}
call2("if", call2(">", expr(x), 1), "a", "b")
# call2(function, param, param) params are leaves of tree
```

















