---
title: 'Chapter 9: Functionals'
author: "Paulo Magalang"
date: "2023-01-17"
output: html_document
---

# 9.1 Introduction

* functional: takes a function as an input and returns a vector as output

```{r}
set.seed(1)

randomise <- function(f) f(runif(1e3))
randomise(mean)
randomise(mean)
randomise(sum)
```

* common examples: R apply family functions, purrr `map()`

# 9.2 My first functional: `map()`

```{r}
library(purrr)
```

* `map(1:3, f)` equivalent to `list(f(1), f(2), f(3))`

```{r}
# map(vector, function)

triple <- function(x) x * 3
map(1:3, triple)
```

```{r}
# basic implementation of map()

simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```

* R base equivalent to `purrr::map()` is `lapply()`


## 9.2.1 Producing atomic vectors

```{r}
# map_chr() always returns a character vector
map_chr(mtcars, typeof)

# map_lgl() always returns a logical vector
map_lgl(mtcars, is.double)

# map_int() always returns a integer vector
n_unique <- function(x) length(unique(x))
map_int(mtcars, n_unique)

# map_dbl() always returns a double vector
map_dbl(mtcars, mean)
```

```{r}
pair <- function(x) c(x, x)
map(1:2, pair)
map(1:2, as.character)
```

* `sapply()` and `vapply()` also outputs atomic vectors

## 9.2.2 Anonymous functions and shortcuts

```{r}
# inline anonymous function
map_dbl(mtcars, function(x) length(unique(x)))
```

```{r}
# purrr shortcut
map_dbl(mtcars, ~ length(unique(.x)))
```

```{r}
as_mapper(~ length(unique(.x)))
```

```{r}
# extracting elements using map()

x <- list(
  list(-1, x = 1, y = c(2), z = "a"),
  list(-2, x = 4, y = c(5, 6), z = "b"),
  list(-3, x = 8, y = c(9, 10, 11))
)

# Select by name
map_dbl(x, "x")

# Or by position
map_dbl(x, 1)

# Or by both
map_dbl(x, list("y", 1))

# You'll get an error if a component doesn't exist:
#map_chr(x, "z")

# Unless you supply a .default value
map_chr(x, "z", .default = NA)
```

## 9.2.3 Passing arguments with `...`

```{r}
x <- list(1:5, c(1:10, NA))
map_dbl(x, ~ mean(.x, na.rm = TRUE))
```

```{r}
# directly pass na.rm to mean(), no need to specify parameters in function call
map_dbl(x, mean, na.rm = TRUE)
```

* arguments passed this way are not decomposed! (ie: passing a vector as an argument
will stay as a vector)

```{r}
plus <- function(x, y) x + y
x <- c(0, 0, 0, 0)

# passing extra arguments in map()
map_dbl(x, plus, runif(1)) # runif() evaluated once

# passing extra arguments in anonymous function
map_dbl(x, ~ plus(.x, runif(1))) # runif() evaluated for each index
```

## 9.2.4 Argument names

```{r}
# can write out full argument names passed through map()
x <- list(1:5, 5:10)
map(x, mean, trim = 0.1)
```

```{r}
simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```

```{r}
# arguments to map() are .x and .f
boostrap_summary <- function(x, f) {
  f(sample(x, replace = TRUE))
}

#simple_map(mtcars, bootstrap_summary, f = mean)
# really simple_map(x = mtcars, f = mean, bootstrap_summary), bootstrap_summary passed as trim in mean()
```

## 9.2.5 Varying another argument

* How to keep first argument of `map()` constant and vary the argument?

```{r}
trims_param <- c(0, 0.1, 0.2, 0.5)
vect <- rcauchy(1000)
```

* manually rearrange argument order using an anonymous function

```{r}
map_dbl(trims_param, ~ mean(vect, trim = .x))
```

```{r}
# more explicit
map_dbl(trims_param, function(trim) mean(vect, trim = trim))
```

* take advantage of argument matching rules

```{r}
map_dbl(trims, mean, x = x)
# this is confusing. no reason to do this
```

## 9.2.6 Exercises

1. Use `as_mapper()` to explore how purrr generates anonymous functions for the integer, character, and list
helpers. What helper allows you to extract attributes? Read the documentation to find out.

```{r}
as_mapper(1)
```

```{r}
as_mapper("a")
```

```{r}
as_mapper(list(1, "a"))
```

If the input is a character vector, numeric vector, or list, it is converted to an
extractor function in `purrr::pluck()`.

2. `map(1:3, ~ runif(2))` is a useful pattern for generating random numbers, but
`map(1:3, runif(2))` is not. Why not? Can you explain why it returns the result
that it does?

`~ runif(2)` is executed for each value in `1:3` while `runif(2)` is executed only
one time BUT why are vector values returned?

```{r}
map(1:3, ~ runif(2))
# map(1:3, function(x) runif(2))
```

```{r}
as_mapper(~ runif(2))
```

```{r}
map(1:3, runif(2))
```

```{r}
as_mapper(runif(2))
```

```{r}
v <- 1:3
rand <- as.list(runif(2)) # rand will always be a double < 1

# from as_mapper(runif(2)) output, I would expect two values to be output since
# runif(2) will generate two random values
# also pluck() behavior
pluck(v[1], rand[[1]], .default = NULL)
pluck(v[1], rand[[2]], .default = NULL)
# input and output vectors must have same dimensions and indices < 1 are treated as 1 as opposed to regular vector behavior
# returning empty vectors

v[rand[[1]]]

# but executing pluck() verbosely from as_mapper() throws an error since v[1] and rand dims are not equal
#pluck(v[1], rand, .default = NULL)
#pluck(v, rand, .default = NULL)

# also pluck_raw() doesn't exist, probably a C wrapper idk
```

3. Use the appropriate `map()` function to:

a. Compute the standard deviation of every column in a numeric data frame.

```{r}
map_dbl(mtcars, ~ sd(.x))
```

b. Compute the standard deviation of every numeric column in a mixed data frame.
(Hint: you'll need to do it in two steps.)

```{r}
library(tidyverse)
mtcars_mixed <- rownames_to_column(mtcars, "name")

#map_dbl(mtcars_mixed, ~ sd(.x)) # will introduce NAs

# determine which columns are numeric
num_col <- map_lgl(mtcars_mixed, is.numeric)

# subset numeric columns and calculate sd
map_dbl(mtcars_mixed[num_col], ~ sd(.x))
```

c. Compute the number of levels for every factor in a data frame.

```{r}
factor_col <- map_lgl(iris, is.factor)
map_int(iris[factor_col], ~ length(levels(.x)))
```

4. The following code simulates the performance of a t-test for non-normal data.
Extract the p-value from each test, then visualize.

```{r}
trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))
p_vals <- map_dbl(trials, "p.value")

boxplot(p_vals, col = "white", horizontal = T)
stripchart(p_vals, method = "jitter", pch = 19, add = TRUE)
```

5. The following code uses a map nested inside another map to apply a function to every
element of a nested list. Why does it fail, and what do you need to do to make it work?

```{r}
x <- list(
  list(1, c(3, 9)),
  list(c(3, 6), 7, c(4, 7, 6))
)

triple <- function(x) x * 3
# map(x, map, .f = triple)
# map is passed to triple() as an argument

#map(x, ~ map(triple(.x)))
map(x, ~ map(.x, triple))
```

6. Use `map()` to fit linear models to the `mtcars` dataset using the formulas stored in
this list:

```{r}
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)

fit_models <- map(formulas, lm, data = mtcars)
```

7. Fit the model `mpg ~ disp` to each of the bootstrap replicates of `mtcars` in the
list below, then extract the $R^2$ of the model fit (Hint: you can compute the $R^2$
with `summary()`.)

```{r}
set.seed(1)
bootstrap <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps <- map(1:10, ~ bootstrap(mtcars))
mod <- mpg ~ disp
mod_fit <- map(bootstraps, ~ lm(mod, data = .x))

# summarize across and extract r.squared
map(map(mod_fit, summary), "r.squared")

# one liner possible but will look ugly
```


























