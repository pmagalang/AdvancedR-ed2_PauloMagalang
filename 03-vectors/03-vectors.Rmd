---
title: 'Chapter 3: Vectors'
author: "Paulo Magalang"
date: "2022-09-08"
output: html_document
---

```{r}
library(lobstr)
```

# 3.1 Introduction

* two types of vectors: atomic and list

  * atomic: all elements have to be the same type
    
  * list: elements can be different types
    
  * NULL: zero length vector
  
* vector attributes (metadata)

  * dimension: turns vectors into matrices
  
  * class: powers the S3 system  (factors, data frames, tibbles)
  
## Quiz

Quiz was done after going through the chapter.

1. What are the four common types of atomic vectors? What are the two rare types?

2. What are attributes? How do you get them and set them?

3. How is a list different from an atomic vector? How is a matrix different from a data frame?

4. Can you have a list that is a matrix? Can a data frame have a column that is a matrix?

5. How do tibbles behave differently from data frames?


# 3.2 Atomic Vectors

* 4 types of atomic vectors: logical, integer, double, character

* numeric vectors: integer and double

* rare types of vectors: complex (not needed in stats) and raw (for binary data)


## 3.2.1 Scalars

* scalar: special syntax to create an individual value

  * logical scalar: TRUE/FALSE, T/F
  
  * double scalar: decimal, scientific, hex; special values Inf, -Inf, NaN
  
  * integer scalar: numeric value followed by an L
  
  * string scalar: surrounded by " or '; escape special characters with \
  
## 3.2.2 Making longer vectors with `c()`

* `c()` to combine

* combining atomic vectors will create another atomic vector (flattening)

* `typeof()`: determine type of vector

* `length()`: determine length of vector

## 3.2.3 Missing Values

* `NA`: missing values

* infectious, computations involving a missing value will return another missing
value

```{r}
# exceptions

NA ^ 0

NA | TRUE

NA & FALSE
```

* use `is.na()` to determine NA in a vector

## 3.2.4 Testing and coercion

* test if a vector is a given type with `is.logical()`, `is.double()`, 
`is.integer()`, `is.character()`, be careful with `is.vector()`, `is.atomic()`,
and `is.numeric()`

* combining different types of atomic vectors will cause elements to be cast/coerced
in a fixed order: character -> double -> integer -> logical

* coerce by using `as.integer()`, `as.double()`, `as.logical()`, `as.chacater()`

## 3.2.5 Exercises

1. How do you create raw and complex scalars?

`raw()` creates a raw vector and `complex()` creates a complex vector.

2. Test your knowledge of the vector coercion rules by predicting the output of the following 
uses of `c()`: 

```{r}
c(1, FALSE) # 1, 0
c("a", 1) # "a", "1"
c(TRUE, 1L) # 1, 1
```

3. Why is `1 == "1"` true? Why is `-1 < FALSE` true? Why is `"one" < 2` false?

```{r}
1 == "1" # 1 was cast into "1", "1" == "1" is true
-1 < FALSE # FALSE was cast into 0, -1 < 0 is true
"one" < 2 # 2 was cast into "2", something about ASCII values probably
```

4. Why is the default missing value, `NA`, a logical vector? What's special about logical
vectors? (Hint: think about `c(FALSE, NA_character_)`.)

* NA will be automatically coerced to the correct type when needed.

* logical values have the lowest priority coercion-wise

* The default for NA is a logical vector because it is able to be coerced into
any other type.

5. Precisely what do `is.atomic()`, `is.numeric()`, and `is.vector()` test for?

* Objects can be atomic but not necessarily vectors (from `is.atomic()` docs)

* `is.vector()` checks the attributes of an object and will return `FALSE` if the object
has any other attributes other than names.

* `is.numeric()` checks to see if the object is `double` or `integer` and values look
numeric (arithmetic, comparisons).


# 3.3 Attributes

## 3.3.1 Getting and setting

* attributes are namve-value pairs that attach metadata onto an object

* `attr()`: retrieve and modify attributes

* `attributes()` and `structure()` retrieve and modify many attributes respectively

```{r}
a <- 1:3
attr(a, "x") <- "abcdef"
attr(a, "x")


attr(a, "y") <- 4:6
str(attributes(a))


# Or equivalently
a <- structure(
  1:3, 
  x = "abcdef",
  y = 4:6
)
str(attributes(a))
```

* most attributes are lost by operations, non permanent

```{r}
attributes(a[1])
attributes(sum(a))
```

* names and dim are attributes that are preserved

## 3.3.2 Names 

```{r}
# 3 ways to name a vector

# When creating it: 
x <- c(a = 1, b = 2, c = 3)

# By assigning a character vector to names()
x <- 1:3
names(x) <- c("a", "b", "c")

# Inline, with setNames():
x <- setNames(1:3, c("a", "b", "c"))
```

* remove names with `x <- unname(x)` or `names(x) <- NULL`

* names should be unique and non-missing (but not enforced), missing names
can be either empty strings or NA

## 3.3.3 Dimensions

* adding `dim` attribute to a vector makes it behave like a 2D/multidim array

```{r}
# Two scalar arguments specify row and column sizes
x <- matrix(1:6, nrow = 2, ncol = 3)
x

# One vector argument to describe all dimensions
y <- array(1:12, c(2, 3, 2))
y

# You can also modify an object in place by setting dim()
z <- 1:6
dim(z) <- c(3, 2)
z
```

```{r}
# vector without dim attribute has NULL dimensions
str(1:3)                   # 1d vector

# matrix with single row or col
str(matrix(1:3, ncol = 1)) # column vector
str(matrix(1:3, nrow = 1)) # row vector

# array with single dimension
str(array(1:3, 3))         # "array" vector
```

## 3.3.4 Exercises

1. How is `setNames()` implemented? How is `unname()` implemented? Read the source code.

```{r}
setNames
unname
```

* `setNames()` uses the assignment form of `names()` to name a vector.

* `unname()` checks to see if the object is a vector or matrix/array and uses
the assignment form of `names()` and `dimnames()` to set the name to NULL respectively.

2. What does `dim()` return when applied to a 1-dimensional vector? When might you use
`NROW()` or `NCOL()`?

```{r}
a <- 1:3
dim(a) # will return NULL

# NROW and NCOL treats vectors as 1-column matrices
```

3. How would you describe the following three objects? What makes them different from `1:5`?

```{r}
x1 <- array(1:5, c(1, 1, 5)) # values filled  along 3rd dimension in the array
x2 <- array(1:5, c(1, 5, 1)) # values filled as a single row in the array
x3 <- array(1:5, c(5, 1, 1)) # values filled as a single column in the array
```

* The three objects are arrays while `1:5` is a vector.

4. An early draft used this code to illustrate `structure()`:

```{r}
z <- structure(1:5, comment = "my attribute", comment2 = "hey")
z

str(attributes(z)) # attribute is there but hidden
```

But when you print that object you donâ€™t see the comment attribute. Why? Is the attribute missing, or is there something else special about it? (Hint: try using help.)

Seems like `comment()` is a function and the `comment` attribute is not printed to the console (from `?comment`).

# 3.4 S3 Atomic Vectors

* `class` vector attribute turns an object to an S3 object, behaves differently when passed into a generic
function

## 3.4.1 Factors

* factors are vectors that contain predefined values, categorical data

* factors built on top of int vectors with:

  - factor: a `class` that makes it behave differently from int vectors
  
  - levels: defines the values stored

```{r}
x <- factor(c("a", "b", "b", "a"))
x

typeof(x)
attributes(x)
```

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

table(sex_char)

table(sex_factor)
```

* ordered factors: behave like regular factors but the order of levels is meaningful

```{r}
grade <- ordered(c("b", "b", "a", "c"), levels = c("c", "b", "a"))
grade
```

* use `stringAsFactors = FALSE` to suppress base R functions that automatically coerce
strings to factors

* factors are built on top of integers, string methods will automatically coerce into
strings; explicitly coerce factors into char if need string-like behavior

## 3.4.2 Dates

* built on double vectors

```{r}
today <- Sys.Date()

typeof(today)
attributes(today)
```

```{r}
date <- as.Date("1970-02-01")
unclass(date)
```

## 3.4.3 Date-times

* two ways of storing date-time info: POSIXct and POSIXlt

* POSIX: Portable Operating System Interface

* ct: calendar time

* lt: local time

```{r}
now_ct <- as.POSIXct("2018-08-01 22:00", tz = "UTC")
now_ct

typeof(now_ct)
attributes(now_ct)
```

```{r}
structure(now_ct, tzone = "Asia/Tokyo")
structure(now_ct, tzone = "America/New_York")
structure(now_ct, tzone = "Australia/Lord_Howe")
structure(now_ct, tzone = "Europe/Paris")
```

## 3.4.4 Durations

* difftimes: represent amount of time between pairs of dates or date-times; built on
doubles, `units` attribute that represents the units of time

```{r}
one_week_1 <- as.difftime(1, units = "weeks")
one_week_1

typeof(one_week_1)
attributes(one_week_1)

one_week_2 <- as.difftime(7, units = "days")
one_week_2

typeof(one_week_2)
attributes(one_week_2)
```

## 3.4.5 Exercises

1. What sort of object does `table()` return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?


```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

typeof(table(sex_factor)) # built on top of int vectors which is expected
attributes(table(sex_factor)) # ldim, dimnames, dimnames$sex_factor, class


sex_factor <- factor(sex_char, levels = c("m", "f", "a", "b", "c")) # just adding random levels
attributes(table(sex_factor)) # dimensions increase with amount of levels defined
```

2. What happens to a factor when you modify its levels?

```{r}
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))
```

Modifying a factors levels will rearrange the vector based on the new ordering of the levels.

3. What does this code do? How do `f2` and `f3` differ from `f1`?

```{r}
f2 <- rev(factor(letters))

f3 <- factor(letters, levels = rev(letters)) # vector values in same order but levels are reversed
```


# 3.5 Lists





















